### 条款01：视C++为语言联邦

C++因其多功能性和灵活性而被广泛使用，但它也因此显得复杂。为了更好地理解和使用C++，可以将其视为一个由四个“次语言”组成的联邦，每个次语言都有自己的规则和规约：

1. **C部分**：
   - 这是C++的基础，它继承了C语言的语法和特性，包括基本的数据类型、数组、指针等。
   - 强调效率和对硬件的直接控制。

2. **面向对象的C++（Object-Oriented C++）**：
   - 包括类、封装、继承、多态等概念。
   - 通过面向对象编程(OOP)的方法，让代码更加模块化、易于维护和扩展。

3. **模板C++（Template C++）**：
   - 支持泛型编程，允许编写与类型无关的代码。
   - 模板使得函数和类可以操作任何数据类型，无需为每种数据类型编写特定版本的函数或类。

4. **STL（标准模板库）**：
   - 是一个强大的库，包含容器（如vector, list）、算法（如sort, find）、迭代器等组件。
   - 提供了丰富的预实现数据结构和算法，简化了开发过程，并提高了代码效率和可靠性。

### 条款02：尽量以const、enum、inline替换 #define

为了避免宏定义带来的潜在问题，建议在C++中优先使用编译器而非预处理器来完成类似的任务：

1. **对于单纯常量，最好以const对象或enums替换#define**：
   - 使用`const`声明常量可以指定其类型，并且作用域可以限制在其声明的作用域内，避免全局污染。
   - `enum`适用于整数类型的常量集合，提供了一种组织相关常量的方式。

2. **对于形似函数的宏，最好改用inline内联函数替换#define**：
   - `inline`函数提供了类型安全和调试能力，同时保留了宏的性能优势（减少函数调用开销）。
   - 内联函数允许进行参数检查，降低了错误的风险，并支持重载，增强了代码的可读性和可维护性。

通过这些做法，不仅可以提高代码的安全性和可读性，还能充分利用C++编译器的优势，减少预处理器可能引入的复杂性和错误。

### 条款03：尽可能使用const

- const指向指针位置不同，含义不同

  在C和C++这类编程语言中，`const`关键字用于声明一个常量，意味着该变量的值不能被程序运行期间修改。当涉及到指针时，`const`关键字的使用位置可以改变其含义，具体来说，它取决于`const`是修饰指针本身还是指针所指向的数据。以下是几种不同的情况：

  1. **指向常量的指针 (Pointer to Constant):**
     - 声明方式：`const type *ptr;` 或 `type const *ptr;`
     - 含义：这种情况下，`const`修饰的是指针所指向的数据。这意味着你不能通过这个指针来修改指向的数据，但你可以改变指针本身让它指向其他数据（如果数据类型兼容）。
     - 示例：
       ```c
       const int *ptr;
       int a = 5, b = 10;
       ptr = &a; // 正确
       // *ptr = 6; // 错误，不能通过ptr修改所指向的值
       ptr = &b; // 正确，可以改变ptr指向另一个int类型的变量
       ```

  2. **常量指针 (Constant Pointer):**
     - 声明方式：`type *const ptr;`
     - 含义：这里`const`修饰的是指针本身，意味着指针的指向地址不可更改，但可以通过指针修改其所指向的数据。
     - 示例：
       ```c
       int a = 5, b = 10;
       int *const ptr = &a; // 初始化时必须指定要指向的地址
       *ptr = 6; // 正确，可以通过ptr修改所指向的值
       // ptr = &b; // 错误，不能改变ptr指向另一个地址
       ```

  3. **指向常量的常量指针 (Constant Pointer to Constant):**
     - 声明方式：`const type *const ptr;` 或 `type const *const ptr;`
     - 含义：这种情况下，既不能通过指针修改指向的数据，也不能改变指针的指向。
     - 示例：
       ```c
       int a = 5;
       const int *const ptr = &a; // 初始化时必须指定要指向的地址
       // *ptr = 6; // 错误，不能通过ptr修改所指向的值
       // ptr = &b; // 错误，不能改变ptr指向另一个地址
       ```

  理解这些区别对于正确地使用指针和避免潜在的错误非常重要。正确应用`const`不仅可以帮助编译器优化代码，还可以提高代码的安全性和可读性。

- mutable 使得变量总是可以被更改
- bitwise constness 即保证函数内不改变变量值，但是const函数返回的指针可能导致后续改变其值，所以编写程序时应该使用”概念上的常量性“
- const 和 non-const函数有着实质性等价的实现时，令non-const版本调用const版本可避免代码重复

### 条款04：确定对象使用前已初始化

- 为内置数据类型提供初始化
- 使用初始化列表，并尽量保证与变量定义顺序相同
- 尽量以local static替换non-local static

### 条款05：了解c++默默编写并调用那些函数