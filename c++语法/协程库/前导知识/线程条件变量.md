# `std::condition_variable` 

æ˜¯ C++ æ ‡å‡†åº“ä¸­ç”¨äºçº¿ç¨‹åŒæ­¥çš„é‡è¦å·¥å…·ä¹‹ä¸€ï¼Œå¸¸ä¸ `std::mutex` é…åˆä½¿ç”¨ã€‚å®ƒå…è®¸ä¸€ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹ç­‰å¾…æŸä¸ªæ¡ä»¶å˜ä¸ºçœŸï¼Œè€Œä¸æ˜¯é¢‘ç¹è½®è¯¢ï¼ˆpollingï¼‰ï¼Œä»è€Œæé«˜æ•ˆç‡å¹¶å‡å°‘èµ„æºæ¶ˆè€—ã€‚

---

## ğŸ§± åŸºæœ¬æ¦‚å¿µ

### 1. å¤´æ–‡ä»¶
```cpp
#include <condition_variable>
```

### 2. æ‰€å±å‘½åç©ºé—´
`std`

---

## ğŸ” ä¸»è¦ç”¨é€”

`std::condition_variable` çš„ä¸»è¦ä½œç”¨æ˜¯ï¼š

- **é˜»å¡çº¿ç¨‹**ï¼Œç›´åˆ°å…¶ä»–çº¿ç¨‹é€šçŸ¥å®ƒæ¡ä»¶å·²æ»¡è¶³ã€‚
- åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ç”¨äºå®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€ä»»åŠ¡è°ƒåº¦ã€äº‹ä»¶é©±åŠ¨ç­‰åœºæ™¯ã€‚

---

## ğŸ› ï¸ æ ¸å¿ƒå‡½æ•°è¯¦è§£

| å‡½æ•°å                                                     | æè¿°                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `notify_one()`                                             | å”¤é†’ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ã€‚å¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹åœ¨ç­‰å¾…ï¼Œåˆ™é€‰æ‹©ä¸€ä¸ªå”¤é†’ã€‚ |
| `notify_all()`                                             | å”¤é†’æ‰€æœ‰æ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ã€‚                                     |
| `wait(std::unique_lock<std::mutex>& lock)`                 | é‡Šæ”¾é”ï¼Œå¹¶å°†å½“å‰çº¿ç¨‹é˜»å¡ï¼Œç›´åˆ°è¢«å…¶ä»–çº¿ç¨‹è°ƒç”¨ `notify_one()` æˆ– `notify_all()`ã€‚å½“è¢«å”¤é†’æ—¶ä¼šé‡æ–°è·å–é”ã€‚ |
| `wait_for(...)`                                            | ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œè¶…æ—¶åè‡ªåŠ¨æ¢å¤ã€‚                               |
| `wait_until(...)`                                          | ç­‰å¾…åˆ°æŸä¸€æ—¶åˆ»ï¼Œè¶…æ—¶åè‡ªåŠ¨æ¢å¤ã€‚                             |
| `wait(std::unique_lock<std::mutex>& lock, Predicate pred)` | ç­‰å¾…ç›´åˆ°è°“è¯ä¸º trueã€‚å†…éƒ¨å¾ªç¯è°ƒç”¨ `wait()` ç›´åˆ°æ¡ä»¶æˆç«‹ã€‚    |

---

## âœ… ä½¿ç”¨æ¨¡å¼ï¼šç­‰å¾…æ¡ä»¶æˆç«‹

é€šå¸¸æ¨èä½¿ç”¨å¸¦è°“è¯ï¼ˆpredicateï¼‰çš„ `wait()` æ–¹æ³•ï¼Œé¿å…è™šå‡å”¤é†’ï¼ˆspurious wakeupï¼‰ã€‚

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void wait_for_ready() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; }); // ç­‰å¾… ready == true
    std::cout << "Ready!" << std::endl;
}

void set_ready() {
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
    cv.notify_all(); // é€šçŸ¥æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
}
```

---

## â±ï¸ è¶…æ—¶ç­‰å¾…ç¤ºä¾‹

### ä½¿ç”¨ `wait_for`

```cpp
std::cv_status status = cv.wait_for(lock, std::chrono::seconds(5));
if (status == std::cv_status::timeout) {
    std::cout << "Timeout occurred\n";
}
```

### ä½¿ç”¨ `wait_until`

```cpp
auto timeout_time = std::chrono::system_clock::now() + std::chrono::seconds(5);
std::cv_status status = cv.wait_until(lock, timeout_time);
if (status == std::cv_status::timeout) {
    std::cout << "Timeout occurred\n";
}
```

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **å¿…é¡»é…åˆ `std::unique_lock<std::mutex>` ä½¿ç”¨**
   - `std::condition_variable::wait()` å¿…é¡»ä¼ å…¥ä¸€ä¸ªå·²ç»åŠ é”çš„ `std::unique_lock<std::mutex>`ã€‚
   - å®ƒä¼šåœ¨è¿›å…¥ç­‰å¾…æ—¶è‡ªåŠ¨é‡Šæ”¾é”ï¼Œåœ¨å”¤é†’åé‡æ–°è·å–é”ã€‚

2. **é¿å…è™šå‡å”¤é†’**
   - å³ä½¿æ²¡æœ‰è°ƒç”¨ `notify`ï¼ŒæŸäº›ç³»ç»Ÿä¹Ÿå¯èƒ½å”¤é†’ç­‰å¾…çº¿ç¨‹ã€‚å› æ­¤å»ºè®®å§‹ç»ˆä½¿ç”¨å¸¦è°“è¯çš„ `wait()`ã€‚

3. **é€šçŸ¥é¡ºåºé—®é¢˜**
   - `notify_one()` åªå”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œé€‚ç”¨äºåªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…çš„æƒ…å†µã€‚
   - `notify_all()` å”¤é†’æ‰€æœ‰çº¿ç¨‹ï¼Œé€‚ç”¨äºå¹¿æ’­å¼é€šçŸ¥ï¼ˆå¦‚å¤šä¸ªæ¶ˆè´¹è€…ï¼‰ã€‚

4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**
   - ç¡®ä¿ `condition_variable` å’Œç›¸å…³çº¿ç¨‹åŒæ­¥å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸæ­£ç¡®ï¼Œé¿å…æ‚¬ç©ºå¼•ç”¨æˆ–è®¿é—®æœªåˆå§‹åŒ–å¯¹è±¡ã€‚

---

## ğŸ§ª ç¤ºä¾‹ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> data_queue;
std::mutex mtx;
std::condition_variable cv;
bool done = false;

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        std::lock_guard<std::mutex> lock(mtx);
        data_queue.push(i);
        std::cout << "Produced: " << i << std::endl;
        cv.notify_one();
    }
    done = true;
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []{ return !data_queue.empty() || done; });
        if (done && data_queue.empty())
            break;
        int value = data_queue.front();
        data_queue.pop();
        lock.unlock();
        std::cout << "Consumed: " << value << std::endl;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}
```

---

## ğŸ“Œ å°ç»“

| ç‰¹æ€§         | è¯´æ˜                                           |
| ------------ | ---------------------------------------------- |
| ç±»å‹         | `std::condition_variable`                      |
| åŒæ­¥æœºåˆ¶     | å¿…é¡»ä¸ `std::unique_lock<std::mutex>` æ­é…ä½¿ç”¨ |
| é˜²æ­¢è™šå‡å”¤é†’ | æ¨èä½¿ç”¨å¸¦è°“è¯çš„ `wait()`                      |
| é€‚ç”¨åœºæ™¯     | çº¿ç¨‹é—´é€šä¿¡ã€ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€çŠ¶æ€å˜æ›´é€šçŸ¥ç­‰  |
| æ€§èƒ½ä¼˜åŠ¿     | é¿å…å¿™ç­‰ï¼ŒèŠ‚çœ CPU èµ„æº                        |

---

å¦‚æœä½ å¯¹ `std::condition_variable_any` æˆ– Windows/Linux å¹³å°ç‰¹å®šå®ç°æ„Ÿå…´è¶£ï¼Œä¹Ÿå¯ä»¥ç»§ç»­æé—®ï¼

`std::condition_variable::wait_for` å’Œ `std::condition_variable::wait_until` éƒ½æ˜¯ç”¨äº**å¸¦è¶…æ—¶çš„ç­‰å¾…æ“ä½œ**ï¼Œå®ƒä»¬çš„åŒºåˆ«ä¸»è¦åœ¨äº**æŒ‡å®šè¶…æ—¶æ—¶é—´çš„æ–¹å¼ä¸åŒ**ã€‚ä¸‹é¢æˆ‘å°†è¯¦ç»†è§£é‡Šå®ƒä»¬çš„å®šä¹‰ã€ä½¿ç”¨æ–¹å¼å’ŒåŒºåˆ«ã€‚



# wait_for wait_untilåˆ°åº•ä»€ä¹ˆåŒºåˆ«

## ğŸ“Œ ä¸€ã€åŸºæœ¬å®šä¹‰

### 1. `wait_for`

```cpp
template <class Rep, class Period>
std::cv_status wait_for(unique_lock<mutex>& lock,
                        const chrono::duration<Rep, Period>& rel_time);
```

- **å‚æ•°å«ä¹‰**ï¼š`rel_time` æ˜¯ä¸€ä¸ªç›¸å¯¹æ—¶é—´ï¼ˆrelative timeï¼‰ï¼Œè¡¨ç¤ºâ€œä»ç°åœ¨å¼€å§‹ç­‰å¤šä¹…â€ã€‚
- **è¿”å›å€¼**ï¼š
  - `std::cv_status::no_timeout`ï¼šåœ¨è¶…æ—¶å‰è¢«å”¤é†’ã€‚
  - `std::cv_status::timeout`ï¼šç­‰å¾…æ—¶é—´åˆ°äº†ä»æœªè¢«å”¤é†’ã€‚

> âœ… ç®€å•ç†è§£ï¼šæœ€å¤šç­‰ `rel_time` è¿™ä¹ˆé•¿çš„æ—¶é—´ã€‚

---

### 2. `wait_until`

```cpp
template <class Clock, class Duration>
std::cv_status wait_until(unique_lock<mutex>& lock,
                          const chrono::time_point<Clock, Duration>& abs_time);
```

- **å‚æ•°å«ä¹‰**ï¼š`abs_time` æ˜¯ä¸€ä¸ªç»å¯¹æ—¶é—´ï¼ˆabsolute timeï¼‰ï¼Œè¡¨ç¤ºâ€œæœ€å¤šç­‰åˆ°ä»€ä¹ˆæ—¶å€™â€ã€‚
- **è¿”å›å€¼**ï¼š
  - `std::cv_status::no_timeout`ï¼šåœ¨æŒ‡å®šæ—¶é—´ç‚¹ä¹‹å‰è¢«å”¤é†’ã€‚
  - `std::cv_status::timeout`ï¼šåˆ°äº†æŒ‡å®šæ—¶é—´ä»æœªè¢«å”¤é†’ã€‚

> âœ… ç®€å•ç†è§£ï¼šæœ€å¤šç­‰åˆ° `abs_time` è¿™ä¸ªæ—¶åˆ»ã€‚

---

## ğŸ”„ äºŒã€æ ¸å¿ƒåŒºåˆ«æ€»ç»“

| ç‰¹æ€§     | `wait_for`              | `wait_until`              |
| -------- | ----------------------- | ------------------------- |
| è¶…æ—¶æ–¹å¼ | ç›¸å¯¹æ—¶é—´ï¼ˆä»ç°åœ¨èµ·ï¼‰    | ç»å¯¹æ—¶é—´ï¼ˆåˆ°æŸä¸ªæ—¶åˆ»ï¼‰    |
| å‚æ•°ç±»å‹ | `std::chrono::duration` | `std::chrono::time_point` |
| ä½¿ç”¨åœºæ™¯ | æƒ³ç­‰å¾…å›ºå®šä¸€æ®µæ—¶é—´      | æƒ³ç­‰å¾…åˆ°æŸä¸€å…·ä½“æ—¶åˆ»      |
| ç¤ºä¾‹è¯­ä¹‰ | â€œç­‰5ç§’â€                 | â€œæœ€å¤šç­‰åˆ°ä¸‹åˆ4ç‚¹â€         |

---

## ğŸ’¡ ä¸‰ã€ä»£ç ç¤ºä¾‹å¯¹æ¯”

å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ¡ä»¶å˜é‡ `cv` å’Œäº’æ–¥é” `mtx`ï¼š

### 1. ä½¿ç”¨ `wait_for`ï¼ˆç­‰å¾…ä¸€æ®µæ—¶é—´ï¼‰

```cpp
std::unique_lock<std::mutex> lock(mtx);
auto status = cv.wait_for(lock, std::chrono::seconds(3));

if (status == std::cv_status::timeout) {
    std::cout << "ç­‰å¾…è¶…æ—¶äº†ï¼Œ3ç§’å†…æ²¡æœ‰è¢«é€šçŸ¥\n";
} else {
    std::cout << "è¢«å…¶ä»–çº¿ç¨‹å”¤é†’äº†\n";
}
```

---

### 2. ä½¿ç”¨ `wait_until`ï¼ˆç­‰å¾…åˆ°æŸä¸ªæ—¶åˆ»ï¼‰

```cpp
std::unique_lock<std::mutex> lock(mtx);

// å½“å‰æ—¶é—´ + 3 ç§’åçš„æ—¶é—´ç‚¹
auto timeout_time = std::chrono::system_clock::now() + std::chrono::seconds(3);
auto status = cv.wait_until(lock, timeout_time);

if (status == std::cv_status::timeout) {
    std::cout << "ç­‰å¾…è¶…æ—¶äº†ï¼Œå·²ç»åˆ°äº†è®¾å®šçš„æ—¶é—´ç‚¹\n";
} else {
    std::cout << "è¢«å…¶ä»–çº¿ç¨‹å”¤é†’äº†\n";
}
```

---

## âš ï¸ å››ã€æ³¨æ„äº‹é¡¹

1. **è™šå‡å”¤é†’ï¼ˆSpurious Wakeupï¼‰**
   - å³ä½¿æ²¡æœ‰è°ƒç”¨ `notify_one()` æˆ– `notify_all()`ï¼Œä¹Ÿå¯èƒ½è¢«å”¤é†’ã€‚
   - æ‰€ä»¥å»ºè®®é…åˆè°“è¯ä½¿ç”¨ï¼ˆå³ä¼ å…¥åˆ¤æ–­æ¡ä»¶ï¼‰æ¥é¿å…é”™è¯¯è¡Œä¸ºã€‚

2. **æ¨èä½¿ç”¨å¸¦è°“è¯çš„ç‰ˆæœ¬**

```cpp
cv.wait_for(lock, timeout, []{ return condition; });
cv.wait_until(lock, timeout_time, []{ return condition; });
```

- å¦‚æœè¶…æ—¶å‰æ¡ä»¶æˆç«‹ï¼Œåˆ™è¿”å› `true`ã€‚
- å¦‚æœè¶…æ—¶ä¸”æ¡ä»¶æœªæˆç«‹ï¼Œåˆ™è¿”å› `false`ã€‚

---

## âœ… äº”ã€ä½•æ—¶é€‰å“ªä¸ªï¼Ÿ

| åœºæ™¯                                | æ¨èå‡½æ•°     |
| ----------------------------------- | ------------ |
| æƒ³ç­‰å¾…ä¸€æ®µå›ºå®šæ—¶é—´ï¼ˆå¦‚3ç§’ï¼‰         | `wait_for`   |
| æƒ³ç­‰å¾…åˆ°æŸä¸ªç‰¹å®šæ—¶é—´ç‚¹ï¼ˆå¦‚ä¸‹åˆ4ç‚¹ï¼‰ | `wait_until` |
| éœ€è¦ç²¾ç¡®æ§åˆ¶æ—¶é—´ç‚¹æˆ–å®šæ—¶ä»»åŠ¡        | `wait_until` |
| æ›´ç›´è§‚ç®€å•åœ°è®¾ç½®ç­‰å¾…æ—¶é•¿            | `wait_for`   |

---

## ğŸ§ª å…­ã€ç»“åˆè°“è¯ä½¿ç”¨çš„å®Œæ•´ç¤ºä¾‹

```cpp
bool data_ready = false;

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);
    auto timeout = std::chrono::system_clock::now() + std::chrono::seconds(5);

    bool success = cv.wait_until(lock, timeout, []{ return data_ready; });

    if (success) {
        std::cout << "æ•°æ®å°±ç»ªï¼Œç»§ç»­å¤„ç†\n";
    } else {
        std::cout << "ç­‰å¾…è¶…æ—¶ï¼Œå–æ¶ˆå¤„ç†\n";
    }
}
```

---

## ğŸ“š æ€»ç»“

| æ–¹æ³•å       | å«ä¹‰             | æ—¶é—´ç±»å‹ | æ˜¯å¦æ¨èå¸¦è°“è¯ |
| ------------ | ---------------- | -------- | -------------- |
| `wait_for`   | ç­‰å¾…ä¸€æ®µæ—¶é—´     | ç›¸å¯¹æ—¶é—´ | âœ… å¼ºçƒˆæ¨è     |
| `wait_until` | ç­‰å¾…åˆ°æŸä¸ªæ—¶é—´ç‚¹ | ç»å¯¹æ—¶é—´ | âœ… å¼ºçƒˆæ¨è     |

ä¸¤è€…åŠŸèƒ½ç›¸ä¼¼ï¼Œä½†ç”¨é€”ç•¥æœ‰ä¸åŒã€‚æ ¹æ®ä½ çš„ä¸šåŠ¡é€»è¾‘é€‰æ‹©åˆé€‚çš„æ–¹æ³•å³å¯ã€‚

å¦‚æœä½ è¿˜æƒ³äº†è§£å¦‚ä½•ç»“åˆ `std::future` æˆ– `std::atomic` ä½¿ç”¨è¿™äº›å‡½æ•°ï¼Œä¹Ÿå¯ä»¥ç»§ç»­é—®æˆ‘ï¼

# lock_guard