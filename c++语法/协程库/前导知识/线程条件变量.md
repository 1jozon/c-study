# `std::condition_variable` 

是 C++ 标准库中用于线程同步的重要工具之一，常与 `std::mutex` 配合使用。它允许一个或多个线程等待某个条件变为真，而不是频繁轮询（polling），从而提高效率并减少资源消耗。

---

## 🧱 基本概念

### 1. 头文件
```cpp
#include <condition_variable>
```

### 2. 所属命名空间
`std`

---

## 🔁 主要用途

`std::condition_variable` 的主要作用是：

- **阻塞线程**，直到其他线程通知它条件已满足。
- 在多线程编程中用于实现生产者-消费者模型、任务调度、事件驱动等场景。

---

## 🛠️ 核心函数详解

| 函数名                                                     | 描述                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `notify_one()`                                             | 唤醒一个正在等待的线程。如果有多个线程在等待，则选择一个唤醒。 |
| `notify_all()`                                             | 唤醒所有正在等待的线程。                                     |
| `wait(std::unique_lock<std::mutex>& lock)`                 | 释放锁，并将当前线程阻塞，直到被其他线程调用 `notify_one()` 或 `notify_all()`。当被唤醒时会重新获取锁。 |
| `wait_for(...)`                                            | 等待一段时间，超时后自动恢复。                               |
| `wait_until(...)`                                          | 等待到某一时刻，超时后自动恢复。                             |
| `wait(std::unique_lock<std::mutex>& lock, Predicate pred)` | 等待直到谓词为 true。内部循环调用 `wait()` 直到条件成立。    |

---

## ✅ 使用模式：等待条件成立

通常推荐使用带谓词（predicate）的 `wait()` 方法，避免虚假唤醒（spurious wakeup）。

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void wait_for_ready() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; }); // 等待 ready == true
    std::cout << "Ready!" << std::endl;
}

void set_ready() {
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
    cv.notify_all(); // 通知所有等待线程
}
```

---

## ⏱️ 超时等待示例

### 使用 `wait_for`

```cpp
std::cv_status status = cv.wait_for(lock, std::chrono::seconds(5));
if (status == std::cv_status::timeout) {
    std::cout << "Timeout occurred\n";
}
```

### 使用 `wait_until`

```cpp
auto timeout_time = std::chrono::system_clock::now() + std::chrono::seconds(5);
std::cv_status status = cv.wait_until(lock, timeout_time);
if (status == std::cv_status::timeout) {
    std::cout << "Timeout occurred\n";
}
```

---

## ⚠️ 注意事项

1. **必须配合 `std::unique_lock<std::mutex>` 使用**
   - `std::condition_variable::wait()` 必须传入一个已经加锁的 `std::unique_lock<std::mutex>`。
   - 它会在进入等待时自动释放锁，在唤醒后重新获取锁。

2. **避免虚假唤醒**
   - 即使没有调用 `notify`，某些系统也可能唤醒等待线程。因此建议始终使用带谓词的 `wait()`。

3. **通知顺序问题**
   - `notify_one()` 只唤醒一个线程，适用于只有一个消费者的情况。
   - `notify_all()` 唤醒所有线程，适用于广播式通知（如多个消费者）。

4. **生命周期管理**
   - 确保 `condition_variable` 和相关线程同步对象的生命周期正确，避免悬空引用或访问未初始化对象。

---

## 🧪 示例：生产者-消费者模型

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> data_queue;
std::mutex mtx;
std::condition_variable cv;
bool done = false;

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        std::lock_guard<std::mutex> lock(mtx);
        data_queue.push(i);
        std::cout << "Produced: " << i << std::endl;
        cv.notify_one();
    }
    done = true;
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []{ return !data_queue.empty() || done; });
        if (done && data_queue.empty())
            break;
        int value = data_queue.front();
        data_queue.pop();
        lock.unlock();
        std::cout << "Consumed: " << value << std::endl;
    }
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);

    t1.join();
    t2.join();

    return 0;
}
```

---

## 📌 小结

| 特性         | 说明                                           |
| ------------ | ---------------------------------------------- |
| 类型         | `std::condition_variable`                      |
| 同步机制     | 必须与 `std::unique_lock<std::mutex>` 搭配使用 |
| 防止虚假唤醒 | 推荐使用带谓词的 `wait()`                      |
| 适用场景     | 线程间通信、生产者-消费者模型、状态变更通知等  |
| 性能优势     | 避免忙等，节省 CPU 资源                        |

---

如果你对 `std::condition_variable_any` 或 Windows/Linux 平台特定实现感兴趣，也可以继续提问！

`std::condition_variable::wait_for` 和 `std::condition_variable::wait_until` 都是用于**带超时的等待操作**，它们的区别主要在于**指定超时时间的方式不同**。下面我将详细解释它们的定义、使用方式和区别。



# wait_for wait_until到底什么区别

## 📌 一、基本定义

### 1. `wait_for`

```cpp
template <class Rep, class Period>
std::cv_status wait_for(unique_lock<mutex>& lock,
                        const chrono::duration<Rep, Period>& rel_time);
```

- **参数含义**：`rel_time` 是一个相对时间（relative time），表示“从现在开始等多久”。
- **返回值**：
  - `std::cv_status::no_timeout`：在超时前被唤醒。
  - `std::cv_status::timeout`：等待时间到了仍未被唤醒。

> ✅ 简单理解：最多等 `rel_time` 这么长的时间。

---

### 2. `wait_until`

```cpp
template <class Clock, class Duration>
std::cv_status wait_until(unique_lock<mutex>& lock,
                          const chrono::time_point<Clock, Duration>& abs_time);
```

- **参数含义**：`abs_time` 是一个绝对时间（absolute time），表示“最多等到什么时候”。
- **返回值**：
  - `std::cv_status::no_timeout`：在指定时间点之前被唤醒。
  - `std::cv_status::timeout`：到了指定时间仍未被唤醒。

> ✅ 简单理解：最多等到 `abs_time` 这个时刻。

---

## 🔄 二、核心区别总结

| 特性     | `wait_for`              | `wait_until`              |
| -------- | ----------------------- | ------------------------- |
| 超时方式 | 相对时间（从现在起）    | 绝对时间（到某个时刻）    |
| 参数类型 | `std::chrono::duration` | `std::chrono::time_point` |
| 使用场景 | 想等待固定一段时间      | 想等待到某一具体时刻      |
| 示例语义 | “等5秒”                 | “最多等到下午4点”         |

---

## 💡 三、代码示例对比

假设我们有一个条件变量 `cv` 和互斥锁 `mtx`：

### 1. 使用 `wait_for`（等待一段时间）

```cpp
std::unique_lock<std::mutex> lock(mtx);
auto status = cv.wait_for(lock, std::chrono::seconds(3));

if (status == std::cv_status::timeout) {
    std::cout << "等待超时了，3秒内没有被通知\n";
} else {
    std::cout << "被其他线程唤醒了\n";
}
```

---

### 2. 使用 `wait_until`（等待到某个时刻）

```cpp
std::unique_lock<std::mutex> lock(mtx);

// 当前时间 + 3 秒后的时间点
auto timeout_time = std::chrono::system_clock::now() + std::chrono::seconds(3);
auto status = cv.wait_until(lock, timeout_time);

if (status == std::cv_status::timeout) {
    std::cout << "等待超时了，已经到了设定的时间点\n";
} else {
    std::cout << "被其他线程唤醒了\n";
}
```

---

## ⚠️ 四、注意事项

1. **虚假唤醒（Spurious Wakeup）**
   - 即使没有调用 `notify_one()` 或 `notify_all()`，也可能被唤醒。
   - 所以建议配合谓词使用（即传入判断条件）来避免错误行为。

2. **推荐使用带谓词的版本**

```cpp
cv.wait_for(lock, timeout, []{ return condition; });
cv.wait_until(lock, timeout_time, []{ return condition; });
```

- 如果超时前条件成立，则返回 `true`。
- 如果超时且条件未成立，则返回 `false`。

---

## ✅ 五、何时选哪个？

| 场景                                | 推荐函数     |
| ----------------------------------- | ------------ |
| 想等待一段固定时间（如3秒）         | `wait_for`   |
| 想等待到某个特定时间点（如下午4点） | `wait_until` |
| 需要精确控制时间点或定时任务        | `wait_until` |
| 更直观简单地设置等待时长            | `wait_for`   |

---

## 🧪 六、结合谓词使用的完整示例

```cpp
bool data_ready = false;

void consumer() {
    std::unique_lock<std::mutex> lock(mtx);
    auto timeout = std::chrono::system_clock::now() + std::chrono::seconds(5);

    bool success = cv.wait_until(lock, timeout, []{ return data_ready; });

    if (success) {
        std::cout << "数据就绪，继续处理\n";
    } else {
        std::cout << "等待超时，取消处理\n";
    }
}
```

---

## 📚 总结

| 方法名       | 含义             | 时间类型 | 是否推荐带谓词 |
| ------------ | ---------------- | -------- | -------------- |
| `wait_for`   | 等待一段时间     | 相对时间 | ✅ 强烈推荐     |
| `wait_until` | 等待到某个时间点 | 绝对时间 | ✅ 强烈推荐     |

两者功能相似，但用途略有不同。根据你的业务逻辑选择合适的方法即可。

如果你还想了解如何结合 `std::future` 或 `std::atomic` 使用这些函数，也可以继续问我！

# lock_guard