在 Unix 和类 Unix 操作系统（如 Linux）中，信号是一种用于通知进程发生了某种事件的异步通知机制。每个信号都有一个预定义的编号和名称，下面列出了一些常用的信号及其数值和用途：

### 常用信号列表

- **`SIGHUP` (1)**: 当终端断开时发送给控制进程（通常是父进程）。常用于指示守护进程重新读取配置文件。
  
- **`SIGINT` (2)**: 由用户输入中断字符（通常为 Ctrl+C）产生，用于请求进程终止。

- **`SIGQUIT` (3)**: 类似于 `SIGINT`，但更倾向于提供一种优雅退出的方式，并生成核心转储文件以供调试使用（通常通过 Ctrl+\ 触发）。

- **`SIGILL` (4)**: 表示非法指令。当程序试图执行无效或不允许的硬件指令时产生。

- **`SIGTRAP` (5)**: 通常由调试器使用来实现断点功能。

- **`SIGABRT` (6)**: 由调用 `abort()` 函数产生，用于异常终止程序并生成核心转储文件。

- **`SIGBUS` (7)**: 总线错误（例如，访问未对齐的数据地址或不存在的物理地址）。

- **`SIGFPE` (8)**: 浮点异常，例如除以零或浮点溢出。

- **`SIGKILL` (9)**: 强制进程立即终止。这是唯一不能被捕获或忽略的信号。

- **`SIGUSR1` (10)**: 用户定义的信号1，可用于应用程序自定义的目的。

- **`SIGSEGV` (11)**: 无效内存引用（段错误），例如访问未分配的内存区域。

- **`SIGUSR2` (12)**: 用户定义的信号2，同样可用于应用程序自定义的目的。

- **`SIGPIPE` (13)**: 尝试写入已关闭的管道或socket连接时产生。

- **`SIGALRM` (14)**: 由 `alarm()` 系统调用设置的定时器到期时产生。

- **`SIGTERM` (15)**: 请求进程终止的标准方式，比 `SIGKILL` 更友好，允许进程进行清理工作。

- **`SIGCHLD` (17)**: 子进程停止或终止时发送给其父进程。

- **`SIGCONT` (18)**: 继续执行暂停的进程（如果可能）。

- **`SIGSTOP` (19)**: 暂停进程的执行，无法被捕获或忽略。

- **`SIGTSTP` (20)**: 类似于 `SIGSTOP`，但是可以被捕获或忽略。通常通过键盘输入 Ctrl+Z 触发。

- **`SIGTTIN` (21)**: 后台进程尝试从控制终端读取数据时产生。

- **`SIGTTOU` (22)**: 后台进程尝试向控制终端写入数据时产生。

- **`SIGURG` (23)**: 紧急情况（out-of-band data, OOB）在网络连接上发生时产生。

- **`SIGXCPU` (24)**: 进程超过了设定的CPU时间限制时产生。

- **`SIGXFSZ` (25)**: 进程尝试扩展文件大小超过系统限制时产生。

- **`SIGVTALRM` (26)**: 虚拟计时器超时时产生（只计算进程执行用户代码的时间）。

- **`SIGPROF` (27)**: 计时器超时时产生（包括进程执行用户代码和内核代码的时间）。

- **`SIGWINCH` (28)**: 终端窗口大小改变时产生。

- **`SIGIO` (29)**: I/O可用时产生，用于异步I/O操作。

- **`SIGPWR` (30)**: 电源故障或系统关机通知。

请注意，信号的具体数值可能会根据不同的操作系统有所不同，以上提供的是一般性的Linux环境下的值。此外，一些特定的操作系统版本可能会定义额外的信号或者对上述信号有略微不同的处理方式。

理解和正确使用这些信号对于开发稳定且响应迅速的应用程序至关重要，尤其是在需要处理异常情况、实现定时任务或管理子进程时。