## [29. ä¸¤æ•°ç›¸é™¤](https://leetcode.cn/problems/divide-two-integers/)

è¿™é“é¢˜æœ‰å‡ ä¸ªæ³¨æ„çš„ç‚¹:

1. intç±»å‹æº¢å‡ºåˆ¤æ–­ï¼ˆINT_MINå’ŒINT_MAXï¼‰

2. äºŒåˆ†æŸ¥æ‰¾è¿‡ç¨‹ï¼Œç´¯åŠ çš„è¿‡ç¨‹ä¼šæœ‰æº¢å‡ºå¯èƒ½

   ```
   while (divisor * index <= dividend) {
               index *= 2;
           }
   ```

   å¦‚è¿™ä¸ªindexè™½ç„¶æ˜¯ä¹˜æ•°ï¼Œä½†æ˜¯dividedä¸ºINT_MAXï¼Œdivisorä¸º1æ—¶ä¼šæº¢å‡º

```
class Solution {
public:
    int divide(int dividend, int divisor) {
        int flag = 1;
        int res=0;
        int index = 1;
        int remainder = 0;
        // è€ƒè™‘è¢«é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (dividend == INT_MIN) {
            if (divisor == 1) {
                return INT_MIN;
            }
            if (divisor == -1) {
                return INT_MAX;
            }
        }
        // è€ƒè™‘é™¤æ•°ä¸ºæœ€å°å€¼çš„æƒ…å†µ
        if (divisor == INT_MIN) {
            return dividend == INT_MIN ? 1 : 0;
        }
        // è€ƒè™‘è¢«é™¤æ•°ä¸º 0 çš„æƒ…å†µ
        if (dividend == 0) {
            return 0;
        }


        if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0)) {
            flag = -1;
        }
        dividend = abs(dividend);
        divisor = abs(divisor);
        cout<<flag<<" "<<divisor<<" "<<dividend<<endl;
        if (dividend < divisor) {
            return 0;
        }

        while (divisor * index <= dividend) {
            index *= 2;
        }
        index /= 2;
        remainder = dividend;
        while (remainder >= divisor) {
            dividend -= divisor * index;
            res += index;
            remainder = dividend;
            cout<<remainder<<" "<<index<<endl;
            index = 1;
            while (divisor * index <= dividend) {
                index *= 2;
            }
            index /= 2;
        }

        return res*flag;
    }
};
```

## [43. å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode.cn/problems/multiply-strings/)

ä¹˜æ•°èŒƒå›´å°äºm+nï¼Œç¬¬ä¸€æ¬¡åšé€‰æ‹©äº†æœ€æ…¢çš„æ–¹æ³•ï¼Œå…ˆå°†num2ä¸­æ¯ä¸ªå­—ç¬¦ä¹˜ä»¥num1ï¼Œç„¶åç›¸åŠ 

```
class Solution {
public:
    string multi(string &num1,int k){
        int n = num1.size();
        string ret = "";
        int flag = 0;
        for(int i=n-1 ; i>=0 ; i--){
            int num = num1[i]-'0';
            num = num*k+flag;
            char ch = num%10 + '0';
            ret += ch;
            // cout<<ch<<" "<<num<<endl;
            flag = num/10;
        }
        if (flag!=0){
            ret += flag+'0';
        }
        reverse(ret.begin(),ret.end());
        // cout<<ret<<endl;
        return ret;
    }

    string plus(string res, string temp)
    {

        string ret = "";
        int len_1 = res.size()-1;
        if(len_1 == -1){
            return temp;
        }
        int len_2 = temp.size()-1;  
        int flag = 0;      
        while(len_2 >=0){
            int num1 = res[len_1]-'0';
            int num2 = temp[len_2]-'0';
            int sum = num1 + num2 + flag;
            flag = sum/10;
            char ch = sum%10 + '0';
            ret += ch;
            // cout<<num1<<" "<<num2<<" "<<ch<<" "<<ret<<endl;
            len_1--;
            len_2--;
        }
        // cout<<ret<<endl;
        while(len_1 >=0){
            int num1 = res[len_1]-'0';
            int sum = num1 + flag;
            flag = sum/10;
            char ch = sum%10 + '0';
            ret += ch;
            len_1--;
            // cout<<num1<<" "<<" "<<ch<<" "<<ret<<endl;
        }
        if(flag != 0){
            char ch = flag + '0';
            ret += ch;
        }
        reverse(ret.begin(),ret.end());
        return ret;
    }

    string multiply(string num1, string num2) {
        string res = "";
        int len_1 = num1.size();
        int len_2 = num2.size();  
        string zero = "0";
        
        // if (len_1<len_2)
        // {
        //     swap(num1,num2);
        //     swap(len_1,len_2);
        // }   
        if(num2 == zero || num1 == zero){
            return zero;
        }

        for(int i=0; i<len_2; i++)
        {
            string temp = multi(num1,num2[i]-'0');
            for(int j = 0 ; j < len_2-1-i ; j++){
                temp += '0';
            }
            
            res = plus(res,temp);
            // cout<<res<<endl;
        }
        return res;
    }
};
```

## [44. é€šé…ç¬¦åŒ¹é…](https://leetcode.cn/problems/wildcard-matching/)

è¸©äº†å¥½å‡ ä¸ªå‘ï¼Œå¥½åœ¨å¤§çš„dpçŠ¶æ€æ›´æ–°æ²¡é—®é¢˜

ğŸ•³å‘æœ‰

1. â€‹    dpçŠ¶æ€æ•°ç»„çš„åˆå§‹å€¼ï¼Œä»¥åŠä¸åŒåŒ¹é…å­—ç¬¦åœ¨å­—ç¬¦ä¸²é¦–å°¾çš„æƒ…å†µ
2.  *å¯åŒ¹é…ç©ºå­—ç¬¦
3.   çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ²¡å†™å‡ºæ¥ï¼Œè€½è¯¯äº†å¾ˆå¤šäº‹ï¼ŒçŠ¶æ€è½¬ç§»ä¹Ÿæœ‰ä¸€å®šé—®é¢˜`dp[j+1 ][i+1 ] = true;`,ä¸æ˜¯æ­£å¸¸çš„è½¬ç§»æ–¹å¼ï¼Œåº”è¯¥é‡‡ç”¨è¿™ç§` dp[i][j] = dp[i][j - 1] | dp[i - 1][j];`

```
class Solution {
public:
    bool isMatch(string s, string p) {
        int n = s.size();
        int m = p.size();
        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, 0));
        dp[0][0] = true;
        for(int i=1 ; i<=m ; i++){
            if(p[i-1] == '*' && dp[0][i-1]){
                dp[0][i] = true;
            }
        }
        for (int i = 0; i < m; i++) {
            char ch = p[i];
            for (int j = 0; j < n; j++) {
                if (dp[j][i] == true) {
                    if (p[i] == s[j]) {
                        dp[j + 1][i + 1] = true;
                    } else if (p[i] == '?') {
                        dp[j + 1][i + 1] = true;
                    }
                }
                if (p[i] == '*' ) 
                {
                    if(dp[j][i] || dp[j][i+1]) {
                    dp[j][i + 1] = true;
                    dp[j + 1][i + 1] = true;
                    }
                    if(j == n-1 && dp[j+1][i]){
                        dp[j+1][i+1] = true;
                    }
                }
            }
        }
        return dp[n][m];
    }
};
```

## [47. å…¨æ’åˆ— II](https://leetcode.cn/problems/permutations-ii/)  ä¸ [46. å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/)

ä¸¤é“é¢˜çœ‹èµ·æ¥å·®ä¸å¤šï¼Œä½†æ˜¯ä¸ºäº†å»é‡å°±ä¼šåœ¨é€’å½’æ—¶é‡‡ç”¨ä¸¤ç§å®Œå…¨ä¸åŒçš„æ–¹å¼ã€‚

47. å…¨æ’åˆ— II é‡‡ç”¨åˆ°æ ‡è®°æ•°ç»„åˆ¤æ–­æŸä¸ªæ•°å­—æ˜¯å¦å·²ç»ä½¿ç”¨ï¼Œæœ‰ä¸€ä¸ªæœ‰æ„æ€çš„ç‚¹å°±æ˜¯å›æº¯çš„å‰ªææ¡ä»¶ä¸­`!flag[j-1]`å¯ä»¥æ›¿æ¢ä¸º`flag[j-1]`,å…¶å®å‰è€…æ˜¯é‡å¤å…ƒç´ ä»å·¦å¾€å³è¿›è¡Œé€‰æ‹©ï¼Œåè€…åˆ™æ˜¯æ¢ç´¢åˆ°é‡å¤å…ƒç´ çš„æœ€åä¸€ä¸ªè¿›è¡Œå›æº¯ï¼Œå®åˆ™éƒ½å¯ä»¥è¾¾åˆ°å»é‡çš„ç›®çš„ã€‚

    ```
    if(flag[j] || (j>0 && nums[j]==nums[j-1] && !flag[j-1])){
                    continue;
                }
    ```

    

48. å…¨æ’åˆ— åˆ™ä¸éœ€è¦æ ‡è®°æ•°ç»„å°±è¡Œï¼Œç›´æ¥é€’å½’äº¤æ¢ä¸åŒçš„æ•°å­—ï¼Œæ¯å¯¹ä¸‹æ ‡äº’æ¢ä¸€æ¬¡ï¼ŒåŒ…æ‹¬è‡ªèº«çš„ä¸‹æ ‡ï¼Œå°±ä¼šå¾—åˆ°å…¨æ’åˆ—ã€‚

```
class Solution {
private:
    vector<vector<int>>res;
    vector<bool>flag;
    vector<int>temp_res;
    void Perm(vector<int>& nums, int i , int n){
        if(i==n+1){
            res.push_back(temp_res);
            return;
        }
        // for(int j=i ; j<=n ; j++){
        //     while(j+1 <= n && nums[j]==nums[j+1]){
        //         // if( i+1>=n || nums[i]!=nums[i+1])
        //         // {
        //         //     res.push_back(nums);
        //         // }
        //         j++;
        //     }
        //         swap(nums[i],nums[j]);
        //         Perm(nums,i+1,n);
        //         swap(nums[i],nums[j]);
            
        // }
        for(int j=0 ; j<=n ; j++){
            if(flag[j] || (j>0 && nums[j]==nums[j-1] && !flag[j-1])){
                continue;
            }
            flag[j] = true;
            temp_res[i] = nums[j];
            Perm(nums,i+1,n);
            flag[j] = false;
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        flag.assign(nums.size(),false);
        temp_res.assign(nums.size(),-1);
        Perm(nums,0,nums.size()-1);
        return res;
    }
};
```

