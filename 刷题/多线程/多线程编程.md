å½“ç„¶å¯ä»¥ï¼ä¸‹é¢æˆ‘å°†ä¸ºä½ **è¯¦ç»†è®²è§£å¹¶å®ç°éƒ¨åˆ†å¤šçº¿ç¨‹ç»ƒä¹ é¢˜ï¼ˆä»åˆçº§åˆ°é«˜çº§ï¼‰**ï¼Œå¸®åŠ©ä½ é€æ­¥æŒæ¡ C++ å¤šçº¿ç¨‹ç¼–ç¨‹çš„æ ¸å¿ƒæŠ€æœ¯ã€‚æˆ‘ä»¬æŒ‰ç…§ **Beginner â†’ Intermediate â†’ Advanced** çš„é¡ºåºæ¥æ¨è¿›ã€‚

---

## ğŸŸ¢ Beginner Levelï¼ˆ10 é¢˜ï¼‰

### 1. Create a thread that prints â€œHello from threadâ€.

```cpp
#include <iostream>
#include <thread>

void hello() {
    std::cout << "Hello from thread\n";
}

int main() {
    std::thread t(hello);
    t.join();
    return 0;
}
```

---

### 2. Launch multiple threads that print their thread IDs.

```cpp
#include <iostream>
#include <thread>
#include <vector>

void print_id() {
    std::cout << "Thread ID: " << std::this_thread::get_id() << '\n';
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i)
        threads.emplace_back(print_id);

    for (auto& t : threads)
        t.join();

    return 0;
}
```

---

### 3. Pass parameters to a thread function.

```cpp
#include <iostream>
#include <thread>

void greet(const std::string& name) {
    std::cout << "Hello, " << name << " from thread\n";
}

int main() {
    std::thread t(greet, "Alice");
    t.join();
    return 0;
}
```

---

### 4. Join and detach threads.

```cpp
#include <iostream>
#include <thread>
#include <chrono>

void wait_and_print() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Detached thread done.\n";
}

int main() {
    std::thread t(wait_and_print);
    t.detach(); // çº¿ç¨‹åœ¨åå°è¿è¡Œ

    std::cout << "Main thread continues...\n";

    std::this_thread::sleep_for(std::chrono::seconds(2)); // ç­‰å¾…å­çº¿ç¨‹å®Œæˆ
    return 0;
}
```

---

### 5. Create a thread that calculates the sum of an array.

```cpp
#include <iostream>
#include <thread>
#include <vector>

void calculate_sum(const std::vector<int>& arr, int* result) {
    *result = 0;
    for (int x : arr) *result += x;
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5};
    int result = 0;

    std::thread t(calculate_sum, std::ref(arr), &result);
    t.join();

    std::cout << "Sum: " << result << "\n";
    return 0;
}
```

---

### 6. Launch threads to compute factorials of different numbers.

```cpp
#include <iostream>
#include <thread>
#include <vector>

int factorial(int n) {
    return (n == 0 || n == 1) ? 1 : n * factorial(n - 1);
}

void compute_factorial(int n) {
    std::cout << "Factorial of " << n << " is " << factorial(n) << "\n";
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 1; i <= 5; ++i)
        threads.emplace_back(compute_factorial, i);

    for (auto& t : threads)
        t.join();

    return 0;
}
```

---

### 7. Synchronize access to a shared variable using `std::mutex`.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;
std::mutex mtx;

void increment_counter() {
    for (int i = 0; i < 1000; ++i) {
        mtx.lock();
        ++counter;
        mtx.unlock();
    }
}

int main() {
    std::thread t1(increment_counter);
    std::thread t2(increment_counter);

    t1.join();
    t2.join();

    std::cout << "Final counter value: " << counter << "\n"; // åº”ä¸º 2000
    return 0;
}
```

---

### 8. Demonstrate a race condition without mutex.

```cpp
#include <iostream>
#include <thread>
#include <vector>

int counter = 0;

void bad_increment() {
    for (int i = 0; i < 10000; ++i)
        ++counter;
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i)
        threads.emplace_back(bad_increment);

    for (auto& t : threads)
        t.join();

    std::cout << "Counter (race condition): " << counter << "\n"; // ä¸ä¸€å®šæ˜¯ 100000
    return 0;
}
```

---

### 9. Use `std::lock_guard` to lock a mutex.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;
std::mutex mtx;

void safe_increment() {
    for (int i = 0; i < 10000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads(10, safe_increment);
    for (auto& t : threads)
        t.join();
    std::cout << "Safe counter: " << counter << "\n"; // æ¥è¿‘ 100000
    return 0;
}
```

---

### 10. Use `std::unique_lock` and `std::mutex`.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int shared_data = 0;

void modify_data() {
    std::unique_lock<std::mutex> lock(mtx);
    ++shared_data;
    lock.unlock(); // å¯æ‰‹åŠ¨è§£é”
    std::cout << "Data modified by thread " << std::this_thread::get_id() << "\n";
}

int main() {
    std::thread t1(modify_data);
    std::thread t2(modify_data);
    t1.join(); t2.join();
    return 0;
}
```

---

## ğŸŸ¡ Intermediate Levelï¼ˆ10 é¢˜ï¼‰

### 1. Use `std::condition_variable` for thread signaling.

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void wait_for_ready() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });
    std::cout << "Worker thread is now active\n";
}

int main() {
    std::thread worker(wait_for_ready);
    std::this_thread::sleep_for(std::chrono::seconds(1));
    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
    }
    cv.notify_one();
    worker.join();
    return 0;
}
```

---

### 2. Implement producer-consumer using queue and condition variable.

[ğŸ‘‰ ç•™ç»™ä¸‹ä¸€éƒ¨åˆ†ç»§ç»­å®ç°]

---

## ğŸ”´ Advanced Levelï¼ˆ5 é¢˜ï¼‰

### 1. Simulate a multithreaded file downloader.

[ğŸ‘‰ è¿™ä¸ªä¼šä½¿ç”¨ `std::async`, `std::future`, HTTP è¯·æ±‚åº“æ¨¡æ‹Ÿï¼Œå¦‚ `libcurl` æˆ– `boost.asio`]

---

## âœ… åç»­è®¡åˆ’å»ºè®®ï¼š

ä½ å¯ä»¥æŒ‰ä»¥ä¸‹èŠ‚å¥ç»ƒä¹ è¿™äº›é¢˜ç›®ï¼š

| å‘¨    | ç›®æ ‡                                 |
| ----- | ------------------------------------ |
| ç¬¬1å‘¨ | å®Œæˆ Beginner Level æ‰€æœ‰é¢˜ç›®         |
| ç¬¬2å‘¨ | å®Œæˆ Intermediate Level å‰10é¢˜       |
| ç¬¬3å‘¨ | å®Œæˆ Intermediate Level å10é¢˜       |
| ç¬¬4å‘¨ | å¼€å§‹æŒ‘æˆ˜ Advanced Levelï¼Œè‡³å°‘å®Œæˆ5é¢˜ |

---

## ğŸ“¦ å·¥å…·æ¨èï¼š

- ç¼–è¯‘å™¨ï¼š`g++ -std=c++17 -pthread`
- è°ƒè¯•å·¥å…·ï¼š`gdb`, `valgrind --tool=helgrind`ï¼ˆæ£€æµ‹çº¿ç¨‹é”™è¯¯ï¼‰
- IDEï¼šVSCode + C/C++ æ’ä»¶ã€CLionã€Visual Studio

---

å¦‚æœä½ å¸Œæœ›æˆ‘ä¸ºä½ å®Œæ•´å®ç°æ‰€æœ‰ 50 é“é¢˜ç›®ï¼ˆåŒ…æ‹¬é¡¹ç›®ç»“æ„ã€Makefileã€æµ‹è¯•ä»£ç ï¼‰ï¼Œæˆ‘å¯ä»¥å¸®ä½ æ‰“åŒ…æˆä¸€ä¸ª GitHub é¡¹ç›®æ¨¡æ¿ã€‚

---

æ˜¯å¦éœ€è¦æˆ‘ä¸ºä½ ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„ GitHub é¡¹ç›®ç»“æ„ï¼Ÿæˆ–è€…ä½ æƒ³å…ˆä»æŸä¸€é“ç‰¹å®šçš„é¢˜ç›®å¼€å§‹æ·±å…¥å­¦ä¹ ï¼Ÿæ¬¢è¿ç»§ç»­æé—® ğŸ˜Š